#lang racket

(define/contract (max-dot-product nums1 nums2)
  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)
  (define n1 (length nums1))
  (define vdp (make-vector n1))
  (vector-set! vdp 0 (* (car nums1) (car nums2)))
  (for ([(vj j) (sequence-tail (in-indexed (in-list nums1)) 1)])
    (vector-set! vdp j (max (vector-ref vdp (sub1 j))
                            (* (car nums2) vj))))
  (for ([vi (in-list (cdr nums2))])
    (define h (vector-ref vdp 0))
    (vector-set! vdp 0 (max h (* vi (car nums1))))
    (for/fold ([h h])
              ([(vj j) (sequence-tail (in-indexed (in-list nums1)) 1)])
      (define hh (vector-ref vdp j))
      (vector-set! vdp j (max (+ h (* vj vi))
                              (* vj vi)
                              (vector-ref vdp (sub1 j))
                              hh))
      hh))
  (vector-ref vdp (sub1 n1)))

(max-dot-product '(2 1 -2 5) '(3 0 -6))
(max-dot-product '(3 -2) '(2 -6 7))
(max-dot-product '(-1 -1) '(1 1))
(max-dot-product '(-3 -8 3 -10 1 3 9) '(9 2 3 7 -9 1 -8 5 -1 -1))
