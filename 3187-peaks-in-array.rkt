#lang racket

(define/contract (count-of-peaks nums queries)
  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))
  (define nums-vec (list->vector nums))
  (define n (vector-length nums-vec))
  (define peak-vec (make-vector n))
  (define (peak? i) (and (< (vector-ref nums-vec (sub1 i)) (vector-ref nums-vec i))
                         (< (vector-ref nums-vec (add1 i)) (vector-ref nums-vec i))))
  (for ([i (in-range 1 (sub1 n))])
    (when (peak? i)
      (vector-set! peak-vec i 1)))
  (define peak-tree (make-vector (* 4 n)))
  (let build! ([s 0] [t (sub1 n)] [p 1])
    (cond [(= s t)
           (define peak-val (vector-ref peak-vec s))
           (vector-set! peak-tree p peak-val)
           peak-val]
          [else
           (define m (quotient (+ s t) 2))
           (define lsum (build! s m (* p 2)))
           (define rsum (build! (add1 m) t (add1 (* p 2))))
           (define curr-sum (+ lsum rsum))
           (vector-set! peak-tree p curr-sum)
           curr-sum]))
  (define (peak-sum l r)
    (if (<= l r)
        (let recr ([s 0] [t (sub1 n)] [p 1])
          (if (and (<= l s) (<= t r))
              (vector-ref peak-tree p)
              (let ([m (quotient (+ s t) 2)])
                (define lsum (if (<= l m) (recr s m (* p 2)) 0))
                (define rsum (if (< m r) (recr (add1 m) t (add1 (* p 2))) 0))
                (+ lsum rsum))))
        0))
  (define (peak-tree-update! pos dval)
    (let recr! ([s 0] [t (sub1 n)] [p 1])
      (when (<= s pos t)
        (vector-set! peak-tree p (+ dval (vector-ref peak-tree p)))
        (unless (= s t)
          (define m (quotient (+ s t) 2))
          (if (<= pos m)
              (recr! s m (* p 2))
              (recr! (add1 m) t (add1 (* p 2))))))))
  (define (peak-update! pos val)
    (define dv (- val (vector-ref peak-vec pos)))
    (unless (zero? dv)
      (vector-set! peak-vec pos val)
      (peak-tree-update! pos dv)))
  (define (valid-peak? pos)
    (< 0 pos (sub1 n)))
  (define (value-update! pos val)
    (vector-set! nums-vec pos val)
    (for ([subpos (in-inclusive-range (sub1 pos) (add1 pos))]
          #:when (valid-peak? subpos))
      (peak-update! subpos (if (peak? subpos) 1 0))))
  (for/fold ([a empty] #:result (reverse a))
            ([q (in-list queries)])
    (match q
      [(list 1 l r)
       (cons (peak-sum (add1 l) (sub1 r)) a)]
      [(list 2 index val)
       (value-update! index val)
       a])))

(count-of-peaks '(3 1 4 2 5) '((2 3 4) (1 0 4)))
(count-of-peaks '(4 1 4 2 1 5) '((2 2 4) (1 0 2) (1 0 4)))
(count-of-peaks '(3 6 9) '((1 1 1) (1 2 2) (2 2 3)))
