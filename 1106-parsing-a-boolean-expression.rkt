#lang racket

(define (eat-single expr)
  (let ((c (car expr))
        (expr-r (cdr expr)))
    (cond ((eq? c #\t) (cons true expr-r))
          ((eq? c #\f) (cons false expr-r))
          ((eq? c #\|)
           (let ((list-out (eat-list expr-r)))
             (cons (ormap identity (car list-out))
                   (cdr list-out))))
          ((eq? c #\&)
           (let ((list-out (eat-list expr-r)))
             (cons (andmap identity (car list-out))
                   (cdr list-out))))
          ((eq? c #\!)
           (let ((list-out (eat-list expr-r)))
             (cons (not (caar list-out))
                   (cdr list-out)))))))

(define (eat-list expr)
  (define (iter result expr-r)
    (if (eq? (car expr-r) #\))
        (cons result (cdr expr-r))
        (let ((single-out (eat-single (cdr expr-r))))
          (iter (cons (car single-out) result)
                (cdr single-out)))))
  (iter null expr))

(define/contract (parse-bool-expr expression)
  (-> string? boolean?)
  (car (eat-single (string->list expression))))

(parse-bool-expr "|(t,f)")
(parse-bool-expr "|(&(t,f,t),t)")
(parse-bool-expr "!(&(t,f))")
(parse-bool-expr "|(&(t,f,t),!(t))")